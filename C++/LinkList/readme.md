具体程序见 [LinkList.cpp](LinkList.cpp)

1. 头结点和头指针的区别：不管带不带头结点，头指针始终指向链表的**第一个结点**，而头结点是带头结点链表中的第一个结点，结点内不存储信息。

2. 引入头结点的优点：
 - 由于开始结点的位置被存放在头结点的指针域中，所以在链表的第一个位置上的操作和表的其他位置上的操作一致，无须进行特殊处理。
 - 无论链表是否空，其头指针是指向头结点的非空指针（空表中头结点的指针域为空），因此空表和非空表的处理也就统一了。

3. 头插法建立单链表，读入数据的顺序与生成链表中的元素的顺序是相反的，每个节点插入的时间复杂度为 O(n)，总的时间复杂度为 O(n)。

4. 尾插法建立单链表，读入数据的顺序与生成链表中元素的顺序一致，但是需要增加一个指向表尾结点的指针，总的时间复杂的为 O(n)。

5. 按序号查找表结点操作先要判断序号 i 是否合法，再从第一个结点开始，顺指针的 next 域逐个往下搜索，直到找到第 i 个结点为止，否则返回最后一个结点 next 指针域 NULL。时间复杂度为 O(n)。

6. 按值查找表结点操作的时间复杂度为 O(n)。

7. 插入结点操作（后插操作），需要先查找待插入位置结点的前驱结点，再进行插入操作。查找操作时间复杂度为 O(n)，插入操作时间复杂度为 O(1)。
```c++
p = GetElement(L, i-1);
s->next = p->next;
p-next = s;
```

8. 前插操作，将待插入结点 *s 插入到 *p 结点之前，可以将 *s 插入到 *p 之后，再交换 s->data 与 p->data 即可。
```c++
s->next = p->next;
p->next = s;
temp = s->data;
s->data = p->data;
p->data = temp;
```

9. 删除结点操作，直接将待删除结点的前驱结点的 next 域指向其后继结点，然后再释放待删除结点的存储空间。
```c++
p = GetElement(L, i-1);
q = p->next;
p->next = q->next;
free(q);
```
